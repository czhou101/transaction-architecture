//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.13
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: simple_test ()
//
module simple_test // "test_top.dut"
(
    input logic clk,
    input logic nrst
);

// Variables generated for SystemC signals
logic sem_memreq1_put_req;
logic sem_memreq1_put_req_d;
logic sem_memreq1_core_req_d;
logic sem_memreq1_core_ready_d;
logic sem_memdone1_get_req;
logic sem_memdone1_get_req_d;
logic sem_memdone1_reg_full;
logic sem_memdone1_reg_full_d;
logic sem_memdone1_core_req_d;
logic signed [31:0] sem_memdone1_core_data_d_address;
logic signed [31:0] sem_memdone1_core_data_d_procId;
logic signed [31:0] sem_memdone1_core_data_d_type;
logic signed [31:0] sem_memdone1_core_data_d_data;
logic signed [31:0] sem_memdone1_core_data_out_address;
logic signed [31:0] sem_memdone1_core_data_out_procId;
logic signed [31:0] sem_memdone1_core_data_out_type;
logic signed [31:0] sem_memdone1_core_data_out_data;
logic FEresponse1_get_req;
logic FEresponse1_get_req_d;
logic FEresponse1_reg_full;
logic FEresponse1_reg_full_d;
logic FEresponse1_core_req_d;
logic signed [31:0] FEresponse1_core_data_d;
logic signed [31:0] FEresponse1_core_data_out;
logic FEresult1_get_req;
logic FEresult1_get_req_d;
logic FEresult1_reg_full;
logic FEresult1_reg_full_d;
logic FEresult1_core_req_d;
logic signed [31:0] FEresult1_core_data_d;
logic signed [31:0] FEresult1_core_data_out;
logic sem_memreq1_clk;
logic sem_memreq1_nrst;
logic sem_memreq1_core_ready;
logic sem_memreq1_core_req;
logic signed [31:0] sem_memreq1_core_data_address;
logic signed [31:0] sem_memreq1_core_data_procId;
logic signed [31:0] sem_memreq1_core_data_type;
logic signed [31:0] sem_memreq1_core_data_data;
logic sem_memdone1_clk;
logic sem_memdone1_nrst;
logic sem_memdone1_core_ready;
logic sem_memdone1_core_req;
logic signed [31:0] sem_memdone1_core_data_address;
logic signed [31:0] sem_memdone1_core_data_procId;
logic signed [31:0] sem_memdone1_core_data_type;
logic signed [31:0] sem_memdone1_core_data_data;
logic FEresponse1_clk;
logic FEresponse1_nrst;
logic FEresponse1_core_ready;
logic FEresponse1_core_req;
logic signed [31:0] FEresponse1_core_data;
logic FEresult1_clk;
logic FEresult1_nrst;
logic FEresult1_core_ready;
logic FEresult1_core_req;
logic signed [31:0] FEresult1_core_data;

// Local parameters generated for C++ constants
localparam logic sem_memreq1_chan_sync = 0;
localparam logic sem_memreq1_cthread = 1;
localparam logic sem_memreq1_always_ready = 0;
localparam logic sem_memdone1_cthread = 1;
localparam logic sem_memdone1_always_ready = 0;
localparam logic FEresponse1_cthread = 1;
localparam logic FEresponse1_always_ready = 0;
localparam logic FEresult1_cthread = 1;
localparam logic FEresult1_always_ready = 0;

// Assignments generated for C++ channel arrays
assign sem_memreq1_clk = clk;
assign sem_memreq1_nrst = nrst;
assign sem_memdone1_clk = clk;
assign sem_memdone1_nrst = nrst;
assign FEresponse1_clk = clk;
assign FEresponse1_nrst = nrst;
assign FEresult1_clk = clk;
assign FEresult1_nrst = nrst;

//------------------------------------------------------------------------------
// Clocked THREAD: sem_memreq1_sync_thread (sct_initiator.h:223:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: sem_memreq1_core_thread (sct_initiator.h:269:5) 

// Thread-local variables
logic sem_memreq1_put_req_d_next;
logic sem_memreq1_core_req_d_next;
logic sem_memreq1_core_ready_d_next;

// Next-state combinational logic
always_comb begin : sem_memreq1_core_thread_comb     // sct_initiator.h:269:5
    sem_memreq1_core_thread_func;
end
function void sem_memreq1_core_thread_func;
    sem_memreq1_core_ready_d_next = sem_memreq1_core_ready_d;
    sem_memreq1_core_req_d_next = sem_memreq1_core_req_d;
    sem_memreq1_put_req_d_next = sem_memreq1_put_req_d;
    sem_memreq1_put_req_d_next = sem_memreq1_put_req;
    sem_memreq1_core_req_d_next = sem_memreq1_core_req;
    sem_memreq1_core_ready_d_next = sem_memreq1_core_ready;
endfunction

// Synchronous register update
always_ff @(posedge sem_memreq1_clk or negedge sem_memreq1_nrst) 
begin : sem_memreq1_core_thread_ff
    if ( ~sem_memreq1_nrst ) begin
        sem_memreq1_put_req_d <= 0;
        sem_memreq1_core_req_d <= 0;
        sem_memreq1_core_ready_d <= 0;
    end
    else begin
        sem_memreq1_put_req_d <= sem_memreq1_put_req_d_next;
        sem_memreq1_core_req_d <= sem_memreq1_core_req_d_next;
        sem_memreq1_core_ready_d <= sem_memreq1_core_ready_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: sem_memreq1_req_control (sct_initiator.h:253:5) 

always_comb 
begin : sem_memreq1_req_control     // sct_initiator.h:253:5
    logic A;
    A = sem_memreq1_put_req != sem_memreq1_put_req_d;
    if (A)
    begin
        sem_memreq1_core_req = 1;
    end else begin
        if (sem_memreq1_core_ready_d)
        begin
            sem_memreq1_core_req = 0;
        end else begin
            sem_memreq1_core_req = sem_memreq1_core_req_d;
        end
    end
end

//------------------------------------------------------------------------------
// Method process: sem_memdone1_ready_control (sct_target.h:243:5) 

always_comb 
begin : sem_memdone1_ready_control     // sct_target.h:243:5
    logic A;
    A = sem_memdone1_get_req != sem_memdone1_get_req_d;
    sem_memdone1_core_ready = A || !sem_memdone1_reg_full;
end

//------------------------------------------------------------------------------
// Method process: sem_memdone1_full_control (sct_target.h:248:5) 

always_comb 
begin : sem_memdone1_full_control     // sct_target.h:248:5
    logic A;
    A = sem_memdone1_get_req != sem_memdone1_get_req_d;
    if (A)
    begin
        sem_memdone1_reg_full = 0;
    end else begin
        if (sem_memdone1_core_req_d)
        begin
            sem_memdone1_reg_full = 1;
        end else begin
            sem_memdone1_reg_full = sem_memdone1_reg_full_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sem_memdone1_core_thread (sct_target.h:260:5) 

// Thread-local variables
logic sem_memdone1_get_req_d_next;
logic sem_memdone1_core_req_d_next;
logic sem_memdone1_reg_full_d_next;
logic signed [31:0] sem_memdone1_core_data_d_address_next;
logic signed [31:0] sem_memdone1_core_data_d_procId_next;
logic signed [31:0] sem_memdone1_core_data_d_type_next;
logic signed [31:0] sem_memdone1_core_data_d_data_next;

// Next-state combinational logic
always_comb begin : sem_memdone1_core_thread_comb     // sct_target.h:260:5
    sem_memdone1_core_thread_func;
end
function void sem_memdone1_core_thread_func;
    sem_memdone1_core_data_d_address_next = sem_memdone1_core_data_d_address;
    sem_memdone1_core_data_d_data_next = sem_memdone1_core_data_d_data;
    sem_memdone1_core_data_d_procId_next = sem_memdone1_core_data_d_procId;
    sem_memdone1_core_data_d_type_next = sem_memdone1_core_data_d_type;
    sem_memdone1_core_req_d_next = sem_memdone1_core_req_d;
    sem_memdone1_get_req_d_next = sem_memdone1_get_req_d;
    sem_memdone1_reg_full_d_next = sem_memdone1_reg_full_d;
    sem_memdone1_get_req_d_next = sem_memdone1_get_req;
    sem_memdone1_core_req_d_next = sem_memdone1_core_req;
    sem_memdone1_reg_full_d_next = sem_memdone1_reg_full;
    if (sem_memdone1_core_req && !sem_memdone1_reg_full)
    begin
        sem_memdone1_core_data_d_address_next = sem_memdone1_core_data_address; sem_memdone1_core_data_d_procId_next = sem_memdone1_core_data_procId; sem_memdone1_core_data_d_type_next = sem_memdone1_core_data_type; sem_memdone1_core_data_d_data_next = sem_memdone1_core_data_data;
    end
endfunction

// Synchronous register update
always_ff @(posedge sem_memdone1_clk or negedge sem_memdone1_nrst) 
begin : sem_memdone1_core_thread_ff
    if ( ~sem_memdone1_nrst ) begin
        sem_memdone1_get_req_d <= 0;
        sem_memdone1_core_req_d <= 0;
        sem_memdone1_reg_full_d <= 0;
        sem_memdone1_core_data_d_address <= 0; sem_memdone1_core_data_d_procId <= 0; sem_memdone1_core_data_d_type <= 0; sem_memdone1_core_data_d_data <= 0;
    end
    else begin
        sem_memdone1_get_req_d <= sem_memdone1_get_req_d_next;
        sem_memdone1_core_req_d <= sem_memdone1_core_req_d_next;
        sem_memdone1_reg_full_d <= sem_memdone1_reg_full_d_next;
        sem_memdone1_core_data_d_address <= sem_memdone1_core_data_d_address_next;
        sem_memdone1_core_data_d_procId <= sem_memdone1_core_data_d_procId_next;
        sem_memdone1_core_data_d_type <= sem_memdone1_core_data_d_type_next;
        sem_memdone1_core_data_d_data <= sem_memdone1_core_data_d_data_next;
    end
end

//------------------------------------------------------------------------------
// Method process: sem_memdone1_put_to_fifo (sct_target.h:229:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: sem_memdone1_core_data_mux (sct_target.h:218:5) 

always_comb 
begin : sem_memdone1_core_data_mux     // sct_target.h:218:5
    if (sem_memdone1_reg_full)
    begin
        sem_memdone1_core_data_out_address = sem_memdone1_core_data_d_address; sem_memdone1_core_data_out_procId = sem_memdone1_core_data_d_procId; sem_memdone1_core_data_out_type = sem_memdone1_core_data_d_type; sem_memdone1_core_data_out_data = sem_memdone1_core_data_d_data;
    end else begin
        sem_memdone1_core_data_out_address = sem_memdone1_core_data_address; sem_memdone1_core_data_out_procId = sem_memdone1_core_data_procId; sem_memdone1_core_data_out_type = sem_memdone1_core_data_type; sem_memdone1_core_data_out_data = sem_memdone1_core_data_data;
    end
end

//------------------------------------------------------------------------------
// Method process: FEresponse1_ready_control (sct_target.h:243:5) 

always_comb 
begin : FEresponse1_ready_control     // sct_target.h:243:5
    logic A;
    A = FEresponse1_get_req != FEresponse1_get_req_d;
    FEresponse1_core_ready = A || !FEresponse1_reg_full;
end

//------------------------------------------------------------------------------
// Method process: FEresponse1_full_control (sct_target.h:248:5) 

always_comb 
begin : FEresponse1_full_control     // sct_target.h:248:5
    logic A;
    A = FEresponse1_get_req != FEresponse1_get_req_d;
    if (A)
    begin
        FEresponse1_reg_full = 0;
    end else begin
        if (FEresponse1_core_req_d)
        begin
            FEresponse1_reg_full = 1;
        end else begin
            FEresponse1_reg_full = FEresponse1_reg_full_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: FEresponse1_core_thread (sct_target.h:260:5) 

// Thread-local variables
logic FEresponse1_get_req_d_next;
logic FEresponse1_core_req_d_next;
logic FEresponse1_reg_full_d_next;
logic signed [31:0] FEresponse1_core_data_d_next;

// Next-state combinational logic
always_comb begin : FEresponse1_core_thread_comb     // sct_target.h:260:5
    FEresponse1_core_thread_func;
end
function void FEresponse1_core_thread_func;
    FEresponse1_core_data_d_next = FEresponse1_core_data_d;
    FEresponse1_core_req_d_next = FEresponse1_core_req_d;
    FEresponse1_get_req_d_next = FEresponse1_get_req_d;
    FEresponse1_reg_full_d_next = FEresponse1_reg_full_d;
    FEresponse1_get_req_d_next = FEresponse1_get_req;
    FEresponse1_core_req_d_next = FEresponse1_core_req;
    FEresponse1_reg_full_d_next = FEresponse1_reg_full;
    if (FEresponse1_core_req && !FEresponse1_reg_full)
    begin
        FEresponse1_core_data_d_next = FEresponse1_core_data;
    end
endfunction

// Synchronous register update
always_ff @(posedge FEresponse1_clk or negedge FEresponse1_nrst) 
begin : FEresponse1_core_thread_ff
    if ( ~FEresponse1_nrst ) begin
        FEresponse1_get_req_d <= 0;
        FEresponse1_core_req_d <= 0;
        FEresponse1_reg_full_d <= 0;
        FEresponse1_core_data_d <= 32'd0;
    end
    else begin
        FEresponse1_get_req_d <= FEresponse1_get_req_d_next;
        FEresponse1_core_req_d <= FEresponse1_core_req_d_next;
        FEresponse1_reg_full_d <= FEresponse1_reg_full_d_next;
        FEresponse1_core_data_d <= FEresponse1_core_data_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: FEresponse1_put_to_fifo (sct_target.h:229:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: FEresponse1_core_data_mux (sct_target.h:218:5) 

always_comb 
begin : FEresponse1_core_data_mux     // sct_target.h:218:5
    if (FEresponse1_reg_full)
    begin
        FEresponse1_core_data_out = FEresponse1_core_data_d;
    end else begin
        FEresponse1_core_data_out = FEresponse1_core_data;
    end
end

//------------------------------------------------------------------------------
// Method process: FEresult1_ready_control (sct_target.h:243:5) 

always_comb 
begin : FEresult1_ready_control     // sct_target.h:243:5
    logic A;
    A = FEresult1_get_req != FEresult1_get_req_d;
    FEresult1_core_ready = A || !FEresult1_reg_full;
end

//------------------------------------------------------------------------------
// Method process: FEresult1_full_control (sct_target.h:248:5) 

always_comb 
begin : FEresult1_full_control     // sct_target.h:248:5
    logic A;
    A = FEresult1_get_req != FEresult1_get_req_d;
    if (A)
    begin
        FEresult1_reg_full = 0;
    end else begin
        if (FEresult1_core_req_d)
        begin
            FEresult1_reg_full = 1;
        end else begin
            FEresult1_reg_full = FEresult1_reg_full_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: FEresult1_core_thread (sct_target.h:260:5) 

// Thread-local variables
logic FEresult1_get_req_d_next;
logic FEresult1_core_req_d_next;
logic FEresult1_reg_full_d_next;
logic signed [31:0] FEresult1_core_data_d_next;

// Next-state combinational logic
always_comb begin : FEresult1_core_thread_comb     // sct_target.h:260:5
    FEresult1_core_thread_func;
end
function void FEresult1_core_thread_func;
    FEresult1_core_data_d_next = FEresult1_core_data_d;
    FEresult1_core_req_d_next = FEresult1_core_req_d;
    FEresult1_get_req_d_next = FEresult1_get_req_d;
    FEresult1_reg_full_d_next = FEresult1_reg_full_d;
    FEresult1_get_req_d_next = FEresult1_get_req;
    FEresult1_core_req_d_next = FEresult1_core_req;
    FEresult1_reg_full_d_next = FEresult1_reg_full;
    if (FEresult1_core_req && !FEresult1_reg_full)
    begin
        FEresult1_core_data_d_next = FEresult1_core_data;
    end
endfunction

// Synchronous register update
always_ff @(posedge FEresult1_clk or negedge FEresult1_nrst) 
begin : FEresult1_core_thread_ff
    if ( ~FEresult1_nrst ) begin
        FEresult1_get_req_d <= 0;
        FEresult1_core_req_d <= 0;
        FEresult1_reg_full_d <= 0;
        FEresult1_core_data_d <= 32'd0;
    end
    else begin
        FEresult1_get_req_d <= FEresult1_get_req_d_next;
        FEresult1_core_req_d <= FEresult1_core_req_d_next;
        FEresult1_reg_full_d <= FEresult1_reg_full_d_next;
        FEresult1_core_data_d <= FEresult1_core_data_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: FEresult1_put_to_fifo (sct_target.h:229:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: FEresult1_core_data_mux (sct_target.h:218:5) 

always_comb 
begin : FEresult1_core_data_mux     // sct_target.h:218:5
    if (FEresult1_reg_full)
    begin
        FEresult1_core_data_out = FEresult1_core_data_d;
    end else begin
        FEresult1_core_data_out = FEresult1_core_data;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: init_thread (top.h:53:5) 

// Thread-local variables
logic sem_memreq1_put_req_next;
logic signed [31:0] sem_memreq1_core_data_address_next;
logic signed [31:0] sem_memreq1_core_data_procId_next;
logic signed [31:0] sem_memreq1_core_data_type_next;
logic signed [31:0] sem_memreq1_core_data_data_next;
logic sem_memdone1_get_req_next;
logic signed [31:0] data_address;
logic signed [31:0] data_address_next;
logic signed [31:0] data_procId;
logic signed [31:0] data_procId_next;
logic signed [31:0] data_type;
logic signed [31:0] data_type_next;
logic signed [31:0] data_data;
logic signed [31:0] data_data_next;
logic FEresponse1_get_req_next;
logic [2:0] init_thread_PROC_STATE;
logic [2:0] init_thread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : init_thread_comb     // top.h:53:5
    init_thread_func;
end
function void init_thread_func;
    integer addr;
    integer id;
    integer t;
    integer d;
    integer data2_address;
    integer data2_procId;
    integer data2_type_v;
    integer data2_data;
    logic TMP_1;
    logic TMP_2;
    logic enable;
    logic A;
    logic TMP_3;
    logic enable_1;
    logic A_1;
    logic TMP_4;
    logic TMP_5;
    logic TMP_6;
    logic TMP_7;
    logic TMP_8;
    TMP_1 = 0;
    TMP_2 = 0;
    A = 0;
    TMP_3 = 0;
    A_1 = 0;
    TMP_4 = 0;
    TMP_5 = 0;
    TMP_6 = 0;
    TMP_7 = 0;
    TMP_8 = 0;
    FEresponse1_get_req_next = FEresponse1_get_req;
    data_address_next = data_address;
    data_data_next = data_data;
    data_procId_next = data_procId;
    data_type_next = data_type;
    sem_memdone1_get_req_next = sem_memdone1_get_req;
    sem_memreq1_core_data_address_next = sem_memreq1_core_data_address;
    sem_memreq1_core_data_data_next = sem_memreq1_core_data_data;
    sem_memreq1_core_data_procId_next = sem_memreq1_core_data_procId;
    sem_memreq1_core_data_type_next = sem_memreq1_core_data_type;
    sem_memreq1_put_req_next = sem_memreq1_put_req;
    init_thread_PROC_STATE_next = init_thread_PROC_STATE;
    
    case (init_thread_PROC_STATE)
        0: begin
            // Call put() begin
            if (sem_memreq1_always_ready || sem_memreq1_core_ready)
            begin
                sem_memreq1_put_req_next = !sem_memreq1_put_req;
                sem_memreq1_core_data_address_next = data_address_next; sem_memreq1_core_data_procId_next = data_procId_next; sem_memreq1_core_data_type_next = data_type_next; sem_memreq1_core_data_data_next = data_data_next;
                TMP_1 = 1;
            end else begin
                TMP_1 = 0;
            end
            // Call put() end
            if (!TMP_1)
            begin
                init_thread_PROC_STATE_next = 1; return;    // top.h:67:40;
            end
            enable = 1;
            // Call get() begin
            data_address_next = sem_memdone1_core_data_out_address; data_procId_next = sem_memdone1_core_data_out_procId; data_type_next = sem_memdone1_core_data_out_type; data_data_next = sem_memdone1_core_data_out_data;
            A = (sem_memdone1_core_req || sem_memdone1_reg_full);
            if (A)
            begin
                sem_memdone1_get_req_next = !sem_memdone1_get_req;
                TMP_2 = enable;
            end else begin
                TMP_2 = 0;
            end
            // Call get() end
            if (!TMP_2)
            begin
                init_thread_PROC_STATE_next = 2; return;    // top.h:71:41;
            end
            enable_1 = 1;
            // Call get() begin
            A_1 = (FEresponse1_core_req || FEresponse1_reg_full);
            if (A_1)
            begin
                FEresponse1_get_req_next = !FEresponse1_get_req;
                TMP_3 = enable_1;
            end else begin
                TMP_3 = 0;
            end
            // Call get() end
            init_thread_PROC_STATE_next = 3; return;    // top.h:78:9;
        end
        1: begin
            // Call put() begin
            if (sem_memreq1_always_ready || sem_memreq1_core_ready)
            begin
                sem_memreq1_put_req_next = !sem_memreq1_put_req;
                sem_memreq1_core_data_address_next = data_address_next; sem_memreq1_core_data_procId_next = data_procId_next; sem_memreq1_core_data_type_next = data_type_next; sem_memreq1_core_data_data_next = data_data_next;
                TMP_4 = 1;
            end else begin
                TMP_4 = 0;
            end
            // Call put() end
            if (!TMP_4)
            begin
                init_thread_PROC_STATE_next = 1; return;    // top.h:67:40;
            end
            enable = 1;
            // Call get() begin
            data_address_next = sem_memdone1_core_data_out_address; data_procId_next = sem_memdone1_core_data_out_procId; data_type_next = sem_memdone1_core_data_out_type; data_data_next = sem_memdone1_core_data_out_data;
            A = (sem_memdone1_core_req || sem_memdone1_reg_full);
            if (A)
            begin
                sem_memdone1_get_req_next = !sem_memdone1_get_req;
                TMP_5 = enable;
            end else begin
                TMP_5 = 0;
            end
            // Call get() end
            if (!TMP_5)
            begin
                init_thread_PROC_STATE_next = 2; return;    // top.h:71:41;
            end
            enable_1 = 1;
            // Call get() begin
            A_1 = (FEresponse1_core_req || FEresponse1_reg_full);
            if (A_1)
            begin
                FEresponse1_get_req_next = !FEresponse1_get_req;
                TMP_6 = enable_1;
            end else begin
                TMP_6 = 0;
            end
            // Call get() end
            init_thread_PROC_STATE_next = 3; return;    // top.h:78:9;
        end
        2: begin
            enable = 1;
            // Call get() begin
            data_address_next = sem_memdone1_core_data_out_address; data_procId_next = sem_memdone1_core_data_out_procId; data_type_next = sem_memdone1_core_data_out_type; data_data_next = sem_memdone1_core_data_out_data;
            A = (sem_memdone1_core_req || sem_memdone1_reg_full);
            if (A)
            begin
                sem_memdone1_get_req_next = !sem_memdone1_get_req;
                TMP_7 = enable;
            end else begin
                TMP_7 = 0;
            end
            // Call get() end
            if (!TMP_7)
            begin
                init_thread_PROC_STATE_next = 2; return;    // top.h:71:41;
            end
            enable_1 = 1;
            // Call get() begin
            A_1 = (FEresponse1_core_req || FEresponse1_reg_full);
            if (A_1)
            begin
                FEresponse1_get_req_next = !FEresponse1_get_req;
                TMP_8 = enable_1;
            end else begin
                TMP_8 = 0;
            end
            // Call get() end
            init_thread_PROC_STATE_next = 3; return;    // top.h:78:9;
        end
        3: begin
            init_thread_PROC_STATE_next = 3; return;    // top.h:81:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge sem_memreq1_clk or negedge nrst) 
begin : init_thread_ff
    if ( ~nrst ) begin
        integer addr;
        integer id;
        integer t;
        integer d;
        integer data2_address;
        integer data2_procId;
        integer data2_type_v;
        integer data2_data;
        addr = 1; id = 1; t = 3; d = 42;
        data_address <= addr;
        data_procId <= id;
        data_type <= t;
        data_data <= d;
        data2_address = 0;
        data2_procId = 0;
        data2_type_v = 0;
        data2_data = 0;
        // Call reset_put() begin
        sem_memreq1_put_req <= 0;
        sem_memreq1_core_data_address <= 0; sem_memreq1_core_data_procId <= 0; sem_memreq1_core_data_type <= 0; sem_memreq1_core_data_data <= 0;
        // Call reset_put() end
        // Call reset_get() begin
        sem_memdone1_get_req <= 0;
        // Call reset_get() end
        init_thread_PROC_STATE <= 0;    // top.h:64:9;
    end
    else begin
        sem_memreq1_put_req <= sem_memreq1_put_req_next;
        sem_memreq1_core_data_address <= sem_memreq1_core_data_address_next;
        sem_memreq1_core_data_procId <= sem_memreq1_core_data_procId_next;
        sem_memreq1_core_data_type <= sem_memreq1_core_data_type_next;
        sem_memreq1_core_data_data <= sem_memreq1_core_data_data_next;
        sem_memdone1_get_req <= sem_memdone1_get_req_next;
        data_address <= data_address_next;
        data_procId <= data_procId_next;
        data_type <= data_type_next;
        data_data <= data_data_next;
        FEresponse1_get_req <= FEresponse1_get_req_next;
        init_thread_PROC_STATE <= init_thread_PROC_STATE_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

FrontEndCacheController fecc1
(
  .sem_memreq1_core_ready_s(sem_memreq1_core_ready),
  .sem_memreq1_core_req_s(sem_memreq1_core_req),
  .sem_memreq1_core_data_address_s(sem_memreq1_core_data_address),
  .sem_memreq1_core_data_procId_s(sem_memreq1_core_data_procId),
  .sem_memreq1_core_data_type_s(sem_memreq1_core_data_type),
  .sem_memreq1_core_data_data_s(sem_memreq1_core_data_data),
  .sem_memdone1_core_ready_s(sem_memdone1_core_ready),
  .sem_memdone1_core_req_s(sem_memdone1_core_req),
  .sem_memdone1_core_data_address_s(sem_memdone1_core_data_address),
  .sem_memdone1_core_data_procId_s(sem_memdone1_core_data_procId),
  .sem_memdone1_core_data_type_s(sem_memdone1_core_data_type),
  .sem_memdone1_core_data_data_s(sem_memdone1_core_data_data),
  .FEresponse1_core_ready_s(FEresponse1_core_ready),
  .FEresponse1_core_req_s(FEresponse1_core_req),
  .FEresponse1_core_data_s(FEresponse1_core_data),
  .FEresult1_core_ready_s(FEresult1_core_ready),
  .FEresult1_core_req_s(FEresult1_core_req),
  .FEresult1_core_data_s(FEresult1_core_data),
  .clk(clk),
  .nrst(nrst)
);

endmodule



//==============================================================================
//
// Module: FrontEndCacheController (top.h:26:5)
//
module FrontEndCacheController // "test_top.dut.fecc1"
(
    output logic sem_memreq1_core_ready_s,
    input logic sem_memreq1_core_req_s,
    input logic signed [31:0] sem_memreq1_core_data_address_s,
    input logic signed [31:0] sem_memreq1_core_data_procId_s,
    input logic signed [31:0] sem_memreq1_core_data_type_s,
    input logic signed [31:0] sem_memreq1_core_data_data_s,
    input logic sem_memdone1_core_ready_s,
    output logic sem_memdone1_core_req_s,
    output logic signed [31:0] sem_memdone1_core_data_address_s,
    output logic signed [31:0] sem_memdone1_core_data_procId_s,
    output logic signed [31:0] sem_memdone1_core_data_type_s,
    output logic signed [31:0] sem_memdone1_core_data_data_s,
    input logic FEresponse1_core_ready_s,
    output logic FEresponse1_core_req_s,
    output logic signed [31:0] FEresponse1_core_data_s,
    input logic FEresult1_core_ready_s,
    output logic FEresult1_core_req_s,
    output logic signed [31:0] FEresult1_core_data_s,
    input logic clk,
    input logic nrst
);

// Variables generated for SystemC signals
logic sem_memreq1_get_req;
logic sem_memreq1_get_req_d;
logic sem_memreq1_reg_full;
logic sem_memreq1_reg_full_d;
logic sem_memreq1_core_req_d;
logic signed [31:0] sem_memreq1_core_data_d_address;
logic signed [31:0] sem_memreq1_core_data_d_procId;
logic signed [31:0] sem_memreq1_core_data_d_type;
logic signed [31:0] sem_memreq1_core_data_d_data;
logic signed [31:0] sem_memreq1_core_data_out_address;
logic signed [31:0] sem_memreq1_core_data_out_procId;
logic signed [31:0] sem_memreq1_core_data_out_type;
logic signed [31:0] sem_memreq1_core_data_out_data;
logic sem_memdone1_put_req;
logic sem_memdone1_put_req_d;
logic sem_memdone1_core_req_d;
logic sem_memdone1_core_ready_d;
logic sem_memdone1_sync_req;
logic sem_memdone1_sync_req_d;
logic signed [31:0] sem_memdone1_sync_data_address;
logic signed [31:0] sem_memdone1_sync_data_procId;
logic signed [31:0] sem_memdone1_sync_data_type;
logic signed [31:0] sem_memdone1_sync_data_data;
logic FEresponse1_put_req;
logic FEresponse1_put_req_d;
logic FEresponse1_core_req_d;
logic FEresponse1_core_ready_d;
logic FEresult1_put_req;
logic FEresult1_put_req_d;
logic FEresult1_core_req_d;
logic FEresult1_core_ready_d;
logic sem_memreq1_clk;
logic sem_memreq1_nrst;
logic sem_memreq1_core_ready;
logic sem_memreq1_core_req;
logic signed [31:0] sem_memreq1_core_data_address;
logic signed [31:0] sem_memreq1_core_data_procId;
logic signed [31:0] sem_memreq1_core_data_type;
logic signed [31:0] sem_memreq1_core_data_data;
logic sem_memdone1_clk;
logic sem_memdone1_nrst;
logic sem_memdone1_core_ready;
logic sem_memdone1_core_req;
logic signed [31:0] sem_memdone1_core_data_address;
logic signed [31:0] sem_memdone1_core_data_procId;
logic signed [31:0] sem_memdone1_core_data_type;
logic signed [31:0] sem_memdone1_core_data_data;
logic FEresponse1_clk;
logic FEresponse1_nrst;
logic FEresponse1_core_ready;
logic FEresponse1_core_req;
logic signed [31:0] FEresponse1_core_data;
logic FEresult1_clk;
logic FEresult1_nrst;
logic FEresult1_core_ready;
logic FEresult1_core_req;
logic signed [31:0] FEresult1_core_data;

// Local parameters generated for C++ constants
localparam logic sem_memreq1_cthread = 1;
localparam logic sem_memreq1_always_ready = 0;
localparam logic sem_memdone1_chan_sync = 1;
localparam logic sem_memdone1_cthread = 1;
localparam logic sem_memdone1_always_ready = 0;
localparam logic FEresponse1_chan_sync = 0;
localparam logic FEresponse1_cthread = 1;
localparam logic FEresponse1_always_ready = 0;
localparam logic FEresult1_chan_sync = 0;
localparam logic FEresult1_cthread = 1;
localparam logic FEresult1_always_ready = 0;

// Assignments generated for C++ channel arrays
assign sem_memreq1_core_ready_s = sem_memreq1_core_ready;
assign sem_memreq1_core_req = sem_memreq1_core_req_s;
assign sem_memreq1_core_data_address = sem_memreq1_core_data_address_s;
assign sem_memreq1_core_data_procId = sem_memreq1_core_data_procId_s;
assign sem_memreq1_core_data_type = sem_memreq1_core_data_type_s;
assign sem_memreq1_core_data_data = sem_memreq1_core_data_data_s;
assign sem_memdone1_core_ready = sem_memdone1_core_ready_s;
assign sem_memdone1_core_req_s = sem_memdone1_core_req;
assign sem_memdone1_core_data_address_s = sem_memdone1_core_data_address;
assign sem_memdone1_core_data_procId_s = sem_memdone1_core_data_procId;
assign sem_memdone1_core_data_type_s = sem_memdone1_core_data_type;
assign sem_memdone1_core_data_data_s = sem_memdone1_core_data_data;
assign FEresponse1_core_ready = FEresponse1_core_ready_s;
assign FEresponse1_core_req_s = FEresponse1_core_req;
assign FEresponse1_core_data_s = FEresponse1_core_data;
assign FEresult1_core_ready = FEresult1_core_ready_s;
assign FEresult1_core_req_s = FEresult1_core_req;
assign FEresult1_core_data_s = FEresult1_core_data;
assign sem_memreq1_clk = clk;
assign sem_memreq1_nrst = nrst;
assign sem_memdone1_clk = clk;
assign sem_memdone1_nrst = nrst;
assign FEresponse1_clk = clk;
assign FEresponse1_nrst = nrst;
assign FEresult1_clk = clk;
assign FEresult1_nrst = nrst;

//------------------------------------------------------------------------------
// Method process: sem_memreq1_ready_control (sct_target.h:243:5) 

always_comb 
begin : sem_memreq1_ready_control     // sct_target.h:243:5
    logic A;
    A = sem_memreq1_get_req != sem_memreq1_get_req_d;
    sem_memreq1_core_ready = A || !sem_memreq1_reg_full;
end

//------------------------------------------------------------------------------
// Method process: sem_memreq1_full_control (sct_target.h:248:5) 

always_comb 
begin : sem_memreq1_full_control     // sct_target.h:248:5
    logic A;
    A = sem_memreq1_get_req != sem_memreq1_get_req_d;
    if (A)
    begin
        sem_memreq1_reg_full = 0;
    end else begin
        if (sem_memreq1_core_req_d)
        begin
            sem_memreq1_reg_full = 1;
        end else begin
            sem_memreq1_reg_full = sem_memreq1_reg_full_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sem_memreq1_core_thread (sct_target.h:260:5) 

// Thread-local variables
logic sem_memreq1_get_req_d_next;
logic sem_memreq1_core_req_d_next;
logic sem_memreq1_reg_full_d_next;
logic signed [31:0] sem_memreq1_core_data_d_address_next;
logic signed [31:0] sem_memreq1_core_data_d_procId_next;
logic signed [31:0] sem_memreq1_core_data_d_type_next;
logic signed [31:0] sem_memreq1_core_data_d_data_next;

// Next-state combinational logic
always_comb begin : sem_memreq1_core_thread_comb     // sct_target.h:260:5
    sem_memreq1_core_thread_func;
end
function void sem_memreq1_core_thread_func;
    sem_memreq1_core_data_d_address_next = sem_memreq1_core_data_d_address;
    sem_memreq1_core_data_d_data_next = sem_memreq1_core_data_d_data;
    sem_memreq1_core_data_d_procId_next = sem_memreq1_core_data_d_procId;
    sem_memreq1_core_data_d_type_next = sem_memreq1_core_data_d_type;
    sem_memreq1_core_req_d_next = sem_memreq1_core_req_d;
    sem_memreq1_get_req_d_next = sem_memreq1_get_req_d;
    sem_memreq1_reg_full_d_next = sem_memreq1_reg_full_d;
    sem_memreq1_get_req_d_next = sem_memreq1_get_req;
    sem_memreq1_core_req_d_next = sem_memreq1_core_req;
    sem_memreq1_reg_full_d_next = sem_memreq1_reg_full;
    if (sem_memreq1_core_req && !sem_memreq1_reg_full)
    begin
        sem_memreq1_core_data_d_address_next = sem_memreq1_core_data_address; sem_memreq1_core_data_d_procId_next = sem_memreq1_core_data_procId; sem_memreq1_core_data_d_type_next = sem_memreq1_core_data_type; sem_memreq1_core_data_d_data_next = sem_memreq1_core_data_data;
    end
endfunction

// Synchronous register update
always_ff @(posedge sem_memreq1_clk or negedge sem_memreq1_nrst) 
begin : sem_memreq1_core_thread_ff
    if ( ~sem_memreq1_nrst ) begin
        sem_memreq1_get_req_d <= 0;
        sem_memreq1_core_req_d <= 0;
        sem_memreq1_reg_full_d <= 0;
        sem_memreq1_core_data_d_address <= 0; sem_memreq1_core_data_d_procId <= 0; sem_memreq1_core_data_d_type <= 0; sem_memreq1_core_data_d_data <= 0;
    end
    else begin
        sem_memreq1_get_req_d <= sem_memreq1_get_req_d_next;
        sem_memreq1_core_req_d <= sem_memreq1_core_req_d_next;
        sem_memreq1_reg_full_d <= sem_memreq1_reg_full_d_next;
        sem_memreq1_core_data_d_address <= sem_memreq1_core_data_d_address_next;
        sem_memreq1_core_data_d_procId <= sem_memreq1_core_data_d_procId_next;
        sem_memreq1_core_data_d_type <= sem_memreq1_core_data_d_type_next;
        sem_memreq1_core_data_d_data <= sem_memreq1_core_data_d_data_next;
    end
end

//------------------------------------------------------------------------------
// Method process: sem_memreq1_put_to_fifo (sct_target.h:229:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Method process: sem_memreq1_core_data_mux (sct_target.h:218:5) 

always_comb 
begin : sem_memreq1_core_data_mux     // sct_target.h:218:5
    if (sem_memreq1_reg_full)
    begin
        sem_memreq1_core_data_out_address = sem_memreq1_core_data_d_address; sem_memreq1_core_data_out_procId = sem_memreq1_core_data_d_procId; sem_memreq1_core_data_out_type = sem_memreq1_core_data_d_type; sem_memreq1_core_data_out_data = sem_memreq1_core_data_d_data;
    end else begin
        sem_memreq1_core_data_out_address = sem_memreq1_core_data_address; sem_memreq1_core_data_out_procId = sem_memreq1_core_data_procId; sem_memreq1_core_data_out_type = sem_memreq1_core_data_type; sem_memreq1_core_data_out_data = sem_memreq1_core_data_data;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sem_memdone1_sync_thread (sct_initiator.h:223:5) 

// Thread-local variables
logic sem_memdone1_sync_req_d_next;
logic sem_memdone1_put_req_next;
logic signed [31:0] sem_memdone1_core_data_address_next;
logic signed [31:0] sem_memdone1_core_data_procId_next;
logic signed [31:0] sem_memdone1_core_data_type_next;
logic signed [31:0] sem_memdone1_core_data_data_next;

// Next-state combinational logic
always_comb begin : sem_memdone1_sync_thread_comb     // sct_initiator.h:223:5
    sem_memdone1_sync_thread_func;
end
function void sem_memdone1_sync_thread_func;
    logic A;
    A = 0;
    sem_memdone1_core_data_address_next = sem_memdone1_core_data_address;
    sem_memdone1_core_data_data_next = sem_memdone1_core_data_data;
    sem_memdone1_core_data_procId_next = sem_memdone1_core_data_procId;
    sem_memdone1_core_data_type_next = sem_memdone1_core_data_type;
    sem_memdone1_put_req_next = sem_memdone1_put_req;
    sem_memdone1_sync_req_d_next = sem_memdone1_sync_req_d;
    A = sem_memdone1_sync_req != sem_memdone1_sync_req_d;
    if (A && sem_memdone1_core_ready)
    begin
        sem_memdone1_put_req_next = !sem_memdone1_put_req;
        sem_memdone1_core_data_address_next = sem_memdone1_sync_data_address; sem_memdone1_core_data_procId_next = sem_memdone1_sync_data_procId; sem_memdone1_core_data_type_next = sem_memdone1_sync_data_type; sem_memdone1_core_data_data_next = sem_memdone1_sync_data_data;
        sem_memdone1_sync_req_d_next = sem_memdone1_sync_req;
    end
endfunction

// Synchronous register update
always_ff @(posedge sem_memdone1_clk or negedge sem_memdone1_nrst) 
begin : sem_memdone1_sync_thread_ff
    if ( ~sem_memdone1_nrst ) begin
        sem_memdone1_sync_req_d <= 0;
        sem_memdone1_put_req <= 0;
        sem_memdone1_core_data_address <= 0; sem_memdone1_core_data_procId <= 0; sem_memdone1_core_data_type <= 0; sem_memdone1_core_data_data <= 0;
    end
    else begin
        sem_memdone1_sync_req_d <= sem_memdone1_sync_req_d_next;
        sem_memdone1_put_req <= sem_memdone1_put_req_next;
        sem_memdone1_core_data_address <= sem_memdone1_core_data_address_next;
        sem_memdone1_core_data_procId <= sem_memdone1_core_data_procId_next;
        sem_memdone1_core_data_type <= sem_memdone1_core_data_type_next;
        sem_memdone1_core_data_data <= sem_memdone1_core_data_data_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: sem_memdone1_core_thread (sct_initiator.h:269:5) 

// Thread-local variables
logic sem_memdone1_put_req_d_next;
logic sem_memdone1_core_req_d_next;
logic sem_memdone1_core_ready_d_next;

// Next-state combinational logic
always_comb begin : sem_memdone1_core_thread_comb     // sct_initiator.h:269:5
    sem_memdone1_core_thread_func;
end
function void sem_memdone1_core_thread_func;
    sem_memdone1_core_ready_d_next = sem_memdone1_core_ready_d;
    sem_memdone1_core_req_d_next = sem_memdone1_core_req_d;
    sem_memdone1_put_req_d_next = sem_memdone1_put_req_d;
    sem_memdone1_put_req_d_next = sem_memdone1_put_req;
    sem_memdone1_core_req_d_next = sem_memdone1_core_req;
    sem_memdone1_core_ready_d_next = sem_memdone1_core_ready;
endfunction

// Synchronous register update
always_ff @(posedge sem_memdone1_clk or negedge sem_memdone1_nrst) 
begin : sem_memdone1_core_thread_ff
    if ( ~sem_memdone1_nrst ) begin
        sem_memdone1_put_req_d <= 0;
        sem_memdone1_core_req_d <= 0;
        sem_memdone1_core_ready_d <= 0;
    end
    else begin
        sem_memdone1_put_req_d <= sem_memdone1_put_req_d_next;
        sem_memdone1_core_req_d <= sem_memdone1_core_req_d_next;
        sem_memdone1_core_ready_d <= sem_memdone1_core_ready_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: sem_memdone1_req_control (sct_initiator.h:253:5) 

always_comb 
begin : sem_memdone1_req_control     // sct_initiator.h:253:5
    logic A;
    A = sem_memdone1_put_req != sem_memdone1_put_req_d;
    if (A)
    begin
        sem_memdone1_core_req = 1;
    end else begin
        if (sem_memdone1_core_ready_d)
        begin
            sem_memdone1_core_req = 0;
        end else begin
            sem_memdone1_core_req = sem_memdone1_core_req_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: FEresponse1_sync_thread (sct_initiator.h:223:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: FEresponse1_core_thread (sct_initiator.h:269:5) 

// Thread-local variables
logic FEresponse1_put_req_d_next;
logic FEresponse1_core_req_d_next;
logic FEresponse1_core_ready_d_next;

// Next-state combinational logic
always_comb begin : FEresponse1_core_thread_comb     // sct_initiator.h:269:5
    FEresponse1_core_thread_func;
end
function void FEresponse1_core_thread_func;
    FEresponse1_core_ready_d_next = FEresponse1_core_ready_d;
    FEresponse1_core_req_d_next = FEresponse1_core_req_d;
    FEresponse1_put_req_d_next = FEresponse1_put_req_d;
    FEresponse1_put_req_d_next = FEresponse1_put_req;
    FEresponse1_core_req_d_next = FEresponse1_core_req;
    FEresponse1_core_ready_d_next = FEresponse1_core_ready;
endfunction

// Synchronous register update
always_ff @(posedge FEresponse1_clk or negedge FEresponse1_nrst) 
begin : FEresponse1_core_thread_ff
    if ( ~FEresponse1_nrst ) begin
        FEresponse1_put_req_d <= 0;
        FEresponse1_core_req_d <= 0;
        FEresponse1_core_ready_d <= 0;
    end
    else begin
        FEresponse1_put_req_d <= FEresponse1_put_req_d_next;
        FEresponse1_core_req_d <= FEresponse1_core_req_d_next;
        FEresponse1_core_ready_d <= FEresponse1_core_ready_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: FEresponse1_req_control (sct_initiator.h:253:5) 

always_comb 
begin : FEresponse1_req_control     // sct_initiator.h:253:5
    logic A;
    A = FEresponse1_put_req != FEresponse1_put_req_d;
    if (A)
    begin
        FEresponse1_core_req = 1;
    end else begin
        if (FEresponse1_core_ready_d)
        begin
            FEresponse1_core_req = 0;
        end else begin
            FEresponse1_core_req = FEresponse1_core_req_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: FEresult1_sync_thread (sct_initiator.h:223:5) 
// Empty process, no code generated 

//------------------------------------------------------------------------------
// Clocked THREAD: FEresult1_core_thread (sct_initiator.h:269:5) 

// Thread-local variables
logic FEresult1_put_req_d_next;
logic FEresult1_core_req_d_next;
logic FEresult1_core_ready_d_next;

// Next-state combinational logic
always_comb begin : FEresult1_core_thread_comb     // sct_initiator.h:269:5
    FEresult1_core_thread_func;
end
function void FEresult1_core_thread_func;
    FEresult1_core_ready_d_next = FEresult1_core_ready_d;
    FEresult1_core_req_d_next = FEresult1_core_req_d;
    FEresult1_put_req_d_next = FEresult1_put_req_d;
    FEresult1_put_req_d_next = FEresult1_put_req;
    FEresult1_core_req_d_next = FEresult1_core_req;
    FEresult1_core_ready_d_next = FEresult1_core_ready;
endfunction

// Synchronous register update
always_ff @(posedge FEresult1_clk or negedge FEresult1_nrst) 
begin : FEresult1_core_thread_ff
    if ( ~FEresult1_nrst ) begin
        FEresult1_put_req_d <= 0;
        FEresult1_core_req_d <= 0;
        FEresult1_core_ready_d <= 0;
    end
    else begin
        FEresult1_put_req_d <= FEresult1_put_req_d_next;
        FEresult1_core_req_d <= FEresult1_core_req_d_next;
        FEresult1_core_ready_d <= FEresult1_core_ready_d_next;
    end
end

//------------------------------------------------------------------------------
// Method process: FEresult1_req_control (sct_initiator.h:253:5) 

always_comb 
begin : FEresult1_req_control     // sct_initiator.h:253:5
    logic A;
    A = FEresult1_put_req != FEresult1_put_req_d;
    if (A)
    begin
        FEresult1_core_req = 1;
    end else begin
        if (FEresult1_core_ready_d)
        begin
            FEresult1_core_req = 0;
        end else begin
            FEresult1_core_req = FEresult1_core_req_d;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: threadProc (mem.h:36:5) 

// Thread-local variables
logic signed [31:0] CACHE_TAG[1];
logic signed [31:0] CACHE_TAG_next[1];
logic signed [31:0] CACHE_STATE[1];
logic signed [31:0] CACHE_STATE_next[1];
logic signed [31:0] CACHE_DATA[1][8];
logic signed [31:0] CACHE_DATA_next[1][8];
logic signed [31:0] response;
logic signed [31:0] response_next;
logic signed [31:0] blkNum;
logic signed [31:0] blkNum_next;
logic signed [31:0] wordOffset;
logic signed [31:0] wordOffset_next;
logic signed [31:0] copyreq1_data;
logic signed [31:0] copyreq1_data_next;
logic signed [31:0] ret;
logic signed [31:0] ret_next;
logic signed [31:0] cacheMissResponse;
logic signed [31:0] cacheMissResponse_next;
logic signed [31:0] req_address;
logic signed [31:0] req_address_next;
logic signed [31:0] req_procId;
logic signed [31:0] req_procId_next;
logic signed [31:0] req_type;
logic signed [31:0] req_type_next;
logic signed [31:0] req_data;
logic signed [31:0] req_data_next;
logic sem_memreq1_get_req_next;
logic sem_memdone1_sync_req_next;
logic signed [31:0] sem_memdone1_sync_data_address_next;
logic signed [31:0] sem_memdone1_sync_data_procId_next;
logic signed [31:0] sem_memdone1_sync_data_type_next;
logic signed [31:0] sem_memdone1_sync_data_data_next;
logic FEresponse1_put_req_next;
logic FEresult1_put_req_next;
logic signed [31:0] FEresult1_core_data_next;
logic signed [31:0] FEresponse1_core_data_next;
logic [1:0] threadProc_PROC_STATE;
logic [1:0] threadProc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : threadProc_comb     // mem.h:36:5
    threadProc_func;
end
function void threadProc_func;
    integer copyreq1_address;
    integer copyreq1_procId;
    integer copyreq1_type_v;
    integer copyreq2_address;
    integer copyreq2_procId;
    integer copyreq2_type_v;
    integer copyreq2_data;
    integer cacheLookupResponse;
    logic TMP_1;
    logic A;
    integer TMP_2_address;
    integer TMP_2_procId;
    integer TMP_2_type_v;
    integer TMP_2_data;
    integer TMP_4;
    integer myTag;
    integer cacheOp;
    integer address;
    logic cacheHit;
    logic TMP_5;
    logic TMP_6;
    integer data;
    logic TMP_7;
    logic TMP_8;
    logic TMP_9;
    logic TMP_10;
    logic TMP_11;
    logic TMP_12;
    logic TMP_13;
    logic TMP_14;
    logic TMP_15;
    logic TMP_16;
    logic TMP_17;
    logic TMP_18;
    logic TMP_19;
    logic TMP_20;
    logic TMP_21;
    logic TMP_22;
    logic TMP_23;
    logic TMP_24;
    logic TMP_25;
    TMP_1 = 0;
    A = 0;
    TMP_2_address = 0;
    TMP_2_procId = 0;
    TMP_2_type_v = 0;
    TMP_2_data = 0;
    TMP_4 = 0;
    myTag = 0;
    cacheOp = 0;
    address = 0;
    cacheHit = 0;
    TMP_5 = 0;
    TMP_6 = 0;
    data = 0;
    TMP_7 = 0;
    TMP_8 = 0;
    TMP_9 = 0;
    TMP_10 = 0;
    TMP_11 = 0;
    TMP_12 = 0;
    TMP_13 = 0;
    TMP_14 = 0;
    TMP_15 = 0;
    TMP_16 = 0;
    TMP_17 = 0;
    TMP_18 = 0;
    TMP_19 = 0;
    TMP_20 = 0;
    TMP_21 = 0;
    TMP_22 = 0;
    TMP_23 = 0;
    TMP_24 = 0;
    TMP_25 = 0;
    CACHE_DATA_next = CACHE_DATA;
    CACHE_STATE_next = CACHE_STATE;
    CACHE_TAG_next = CACHE_TAG;
    FEresponse1_core_data_next = FEresponse1_core_data;
    FEresponse1_put_req_next = FEresponse1_put_req;
    FEresult1_core_data_next = FEresult1_core_data;
    FEresult1_put_req_next = FEresult1_put_req;
    blkNum_next = blkNum;
    cacheMissResponse_next = cacheMissResponse;
    copyreq1_data_next = copyreq1_data;
    req_address_next = req_address;
    req_data_next = req_data;
    req_procId_next = req_procId;
    req_type_next = req_type;
    response_next = response;
    ret_next = ret;
    sem_memdone1_sync_data_address_next = sem_memdone1_sync_data_address;
    sem_memdone1_sync_data_data_next = sem_memdone1_sync_data_data;
    sem_memdone1_sync_data_procId_next = sem_memdone1_sync_data_procId;
    sem_memdone1_sync_data_type_next = sem_memdone1_sync_data_type;
    sem_memdone1_sync_req_next = sem_memdone1_sync_req;
    sem_memreq1_get_req_next = sem_memreq1_get_req;
    wordOffset_next = wordOffset;
    threadProc_PROC_STATE_next = threadProc_PROC_STATE;
    
    case (threadProc_PROC_STATE)
        0: begin
            // Call clear_put() begin
            sem_memdone1_sync_req_next = sem_memdone1_sync_req;
            // Call clear_put() end
            // Call clear_put() begin
            FEresponse1_put_req_next = FEresponse1_put_req;
            // Call clear_put() end
            // Call clear_put() begin
            FEresult1_put_req_next = FEresult1_put_req;
            // Call clear_put() end
            // Call request() begin
            TMP_1 = sem_memreq1_core_req || sem_memreq1_reg_full;
            // Call request() end
            if (TMP_1)
            begin
                // Call get() begin
                A = (sem_memreq1_core_req || sem_memreq1_reg_full);
                if (A)
                begin
                    sem_memreq1_get_req_next = !sem_memreq1_get_req;
                end
                TMP_2_address = sem_memreq1_core_data_out_address; TMP_2_procId = sem_memreq1_core_data_out_procId; TMP_2_type_v = sem_memreq1_core_data_out_type; TMP_2_data = sem_memreq1_core_data_out_data;
                // Call get() end
                req_address_next = TMP_2_address; req_procId_next = TMP_2_procId; req_type_next = TMP_2_type_v; req_data_next = TMP_2_data;
                copyreq1_address = req_address_next; copyreq1_procId = req_procId_next; copyreq1_type_v = req_type_next; copyreq1_data_next = req_data_next;
                copyreq2_address = req_address_next; copyreq2_procId = req_procId_next; copyreq2_type_v = req_type_next; copyreq2_data = req_data_next;
                // Call LookupCache() begin
                cacheHit = 0;
                address = copyreq1_address;
                blkNum_next = (address >>> 5) % (1 <<< 0);
                myTag = (address >>> 5) / (1 <<< 0);
                wordOffset_next = (address % (1 <<< 5)) >>> 2;
                cacheOp = copyreq1_type_v;
                if ((CACHE_TAG_next[blkNum_next] == myTag) && (CACHE_STATE_next[blkNum_next] != 3))
                begin
                    cacheHit = 1;
                end
                case (cacheOp)
                2 : begin
                    threadProc_PROC_STATE_next = 1; return;    // mem.h:147:17;
                end
                3 : begin
                    threadProc_PROC_STATE_next = 2; return;    // mem.h:154:17;
                end
                0 : begin
                    if (!cacheHit)
                    begin
                        ret_next = 0;
                    end else begin
                        copyreq1_data_next = CACHE_DATA_next[blkNum_next][wordOffset_next];
                        // Call put() begin
                        if (FEresult1_always_ready || FEresult1_core_ready)
                        begin
                            FEresult1_put_req_next = !FEresult1_put_req;
                            FEresult1_core_data_next = copyreq1_data_next;
                            TMP_5 = 1;
                        end else begin
                            TMP_5 = 0;
                        end
                        // Call put() end
                        ret_next = 1;
                    end
                end
                1 : begin
                    if (!cacheHit)
                    begin
                        ret_next = 0;
                    end else begin
                        if (CACHE_STATE_next[blkNum_next] == 1)
                        begin
                            CACHE_DATA_next[blkNum_next][wordOffset_next] = copyreq1_data_next;
                            ret_next = 1;
                        end else begin
                            if (CACHE_STATE_next[blkNum_next] == 2)
                            begin
                                copyreq1_type_v = 4;
                                threadProc_PROC_STATE_next = 3; return;    // mem.h:188:21;
                            end
                        end
                    end
                end
                endcase
                TMP_4 = ret_next;
                // Call LookupCache() end
                cacheLookupResponse = TMP_4;
                case (cacheLookupResponse)
                2 : begin
                    data = 2;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_6 = 1;
                    end else begin
                        TMP_6 = 0;
                    end
                    // Call put() end
                end
                1 : begin
                    data = 1;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_7 = 1;
                    end else begin
                        TMP_7 = 0;
                    end
                    // Call put() end
                end
                0 : begin
                    case (cacheMissResponse_next)
                    1 : begin
                        data = 1;
                        // Call put() begin
                        if (FEresponse1_always_ready || FEresponse1_core_ready)
                        begin
                            FEresponse1_put_req_next = !FEresponse1_put_req;
                            FEresponse1_core_data_next = data;
                            TMP_8 = 1;
                        end else begin
                            TMP_8 = 0;
                        end
                        // Call put() end
                    end
                    2 : begin
                        data = 2;
                        // Call put() begin
                        if (FEresponse1_always_ready || FEresponse1_core_ready)
                        begin
                            FEresponse1_put_req_next = !FEresponse1_put_req;
                            FEresponse1_core_data_next = data;
                            TMP_9 = 1;
                        end else begin
                            TMP_9 = 0;
                        end
                        // Call put() end
                    end
                    default : begin
                    end
                    endcase
                end
                endcase
                // Call put() begin
                if (sem_memdone1_core_ready)
                begin
                    sem_memdone1_sync_req_next = !sem_memdone1_sync_req;
                    sem_memdone1_sync_data_address_next = req_address_next; sem_memdone1_sync_data_procId_next = req_procId_next; sem_memdone1_sync_data_type_next = req_type_next; sem_memdone1_sync_data_data_next = req_data_next;
                    TMP_10 = 1;
                end else begin
                    TMP_10 = 0;
                end
                // Call put() end
            end
            threadProc_PROC_STATE_next = 0; return;    // mem.h:51:13;
        end
        1: begin
            // Call LookupCache() begin
            ret_next = 1;
            TMP_4 = ret_next;
            // Call LookupCache() end
            cacheLookupResponse = TMP_4;
            case (cacheLookupResponse)
            2 : begin
                data = 2;
                // Call put() begin
                if (FEresponse1_always_ready || FEresponse1_core_ready)
                begin
                    FEresponse1_put_req_next = !FEresponse1_put_req;
                    FEresponse1_core_data_next = data;
                    TMP_11 = 1;
                end else begin
                    TMP_11 = 0;
                end
                // Call put() end
            end
            1 : begin
                data = 1;
                // Call put() begin
                if (FEresponse1_always_ready || FEresponse1_core_ready)
                begin
                    FEresponse1_put_req_next = !FEresponse1_put_req;
                    FEresponse1_core_data_next = data;
                    TMP_12 = 1;
                end else begin
                    TMP_12 = 0;
                end
                // Call put() end
            end
            0 : begin
                case (cacheMissResponse_next)
                1 : begin
                    data = 1;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_13 = 1;
                    end else begin
                        TMP_13 = 0;
                    end
                    // Call put() end
                end
                2 : begin
                    data = 2;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_14 = 1;
                    end else begin
                        TMP_14 = 0;
                    end
                    // Call put() end
                end
                default : begin
                end
                endcase
            end
            endcase
            // Call put() begin
            if (sem_memdone1_core_ready)
            begin
                sem_memdone1_sync_req_next = !sem_memdone1_sync_req;
                sem_memdone1_sync_data_address_next = req_address_next; sem_memdone1_sync_data_procId_next = req_procId_next; sem_memdone1_sync_data_type_next = req_type_next; sem_memdone1_sync_data_data_next = req_data_next;
                TMP_15 = 1;
            end else begin
                TMP_15 = 0;
            end
            // Call put() end
            threadProc_PROC_STATE_next = 0; return;    // mem.h:51:13;
        end
        2: begin
            // Call LookupCache() begin
            ret_next = 1;
            TMP_4 = ret_next;
            // Call LookupCache() end
            cacheLookupResponse = TMP_4;
            case (cacheLookupResponse)
            2 : begin
                data = 2;
                // Call put() begin
                if (FEresponse1_always_ready || FEresponse1_core_ready)
                begin
                    FEresponse1_put_req_next = !FEresponse1_put_req;
                    FEresponse1_core_data_next = data;
                    TMP_16 = 1;
                end else begin
                    TMP_16 = 0;
                end
                // Call put() end
            end
            1 : begin
                data = 1;
                // Call put() begin
                if (FEresponse1_always_ready || FEresponse1_core_ready)
                begin
                    FEresponse1_put_req_next = !FEresponse1_put_req;
                    FEresponse1_core_data_next = data;
                    TMP_17 = 1;
                end else begin
                    TMP_17 = 0;
                end
                // Call put() end
            end
            0 : begin
                case (cacheMissResponse_next)
                1 : begin
                    data = 1;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_18 = 1;
                    end else begin
                        TMP_18 = 0;
                    end
                    // Call put() end
                end
                2 : begin
                    data = 2;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_19 = 1;
                    end else begin
                        TMP_19 = 0;
                    end
                    // Call put() end
                end
                default : begin
                end
                endcase
            end
            endcase
            // Call put() begin
            if (sem_memdone1_core_ready)
            begin
                sem_memdone1_sync_req_next = !sem_memdone1_sync_req;
                sem_memdone1_sync_data_address_next = req_address_next; sem_memdone1_sync_data_procId_next = req_procId_next; sem_memdone1_sync_data_type_next = req_type_next; sem_memdone1_sync_data_data_next = req_data_next;
                TMP_20 = 1;
            end else begin
                TMP_20 = 0;
            end
            // Call put() end
            threadProc_PROC_STATE_next = 0; return;    // mem.h:51:13;
        end
        3: begin
            // Call LookupCache() begin
            if (response_next == 1)
            begin
                CACHE_STATE_next[blkNum_next] = 1;
                CACHE_DATA_next[blkNum_next][wordOffset_next] = copyreq1_data_next;
                ret_next = 1;
            end else begin
                if (response_next == 2)
                begin
                    ret_next = 2;
                end
            end
            TMP_4 = ret_next;
            // Call LookupCache() end
            cacheLookupResponse = TMP_4;
            case (cacheLookupResponse)
            2 : begin
                data = 2;
                // Call put() begin
                if (FEresponse1_always_ready || FEresponse1_core_ready)
                begin
                    FEresponse1_put_req_next = !FEresponse1_put_req;
                    FEresponse1_core_data_next = data;
                    TMP_21 = 1;
                end else begin
                    TMP_21 = 0;
                end
                // Call put() end
            end
            1 : begin
                data = 1;
                // Call put() begin
                if (FEresponse1_always_ready || FEresponse1_core_ready)
                begin
                    FEresponse1_put_req_next = !FEresponse1_put_req;
                    FEresponse1_core_data_next = data;
                    TMP_22 = 1;
                end else begin
                    TMP_22 = 0;
                end
                // Call put() end
            end
            0 : begin
                case (cacheMissResponse_next)
                1 : begin
                    data = 1;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_23 = 1;
                    end else begin
                        TMP_23 = 0;
                    end
                    // Call put() end
                end
                2 : begin
                    data = 2;
                    // Call put() begin
                    if (FEresponse1_always_ready || FEresponse1_core_ready)
                    begin
                        FEresponse1_put_req_next = !FEresponse1_put_req;
                        FEresponse1_core_data_next = data;
                        TMP_24 = 1;
                    end else begin
                        TMP_24 = 0;
                    end
                    // Call put() end
                end
                default : begin
                end
                endcase
            end
            endcase
            // Call put() begin
            if (sem_memdone1_core_ready)
            begin
                sem_memdone1_sync_req_next = !sem_memdone1_sync_req;
                sem_memdone1_sync_data_address_next = req_address_next; sem_memdone1_sync_data_procId_next = req_procId_next; sem_memdone1_sync_data_type_next = req_type_next; sem_memdone1_sync_data_data_next = req_data_next;
                TMP_25 = 1;
            end else begin
                TMP_25 = 0;
            end
            // Call put() end
            threadProc_PROC_STATE_next = 0; return;    // mem.h:51:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge sem_memreq1_clk or negedge nrst) 
begin : threadProc_ff
    if ( ~nrst ) begin
        integer copyreq1_address;
        integer copyreq1_procId;
        integer copyreq1_type_v;
        integer copyreq2_address;
        integer copyreq2_procId;
        integer copyreq2_type_v;
        integer copyreq2_data;
        // Call reset_get() begin
        sem_memreq1_get_req <= 0;
        // Call reset_get() end
        // Call reset_put() begin
        sem_memdone1_sync_req <= 0;
        sem_memdone1_sync_data_address <= 0; sem_memdone1_sync_data_procId <= 0; sem_memdone1_sync_data_type <= 0; sem_memdone1_sync_data_data <= 0;
        // Call reset_put() end
        copyreq1_address = 0;
        copyreq1_procId = 0;
        copyreq1_type_v = 0;
        copyreq1_data <= 0;
        copyreq2_address = 0;
        copyreq2_procId = 0;
        copyreq2_type_v = 0;
        copyreq2_data = 0;
        threadProc_PROC_STATE <= 0;    // mem.h:51:13;
    end
    else begin
        CACHE_TAG <= CACHE_TAG_next;
        CACHE_STATE <= CACHE_STATE_next;
        CACHE_DATA <= CACHE_DATA_next;
        response <= response_next;
        blkNum <= blkNum_next;
        wordOffset <= wordOffset_next;
        copyreq1_data <= copyreq1_data_next;
        ret <= ret_next;
        cacheMissResponse <= cacheMissResponse_next;
        req_address <= req_address_next;
        req_procId <= req_procId_next;
        req_type <= req_type_next;
        req_data <= req_data_next;
        sem_memreq1_get_req <= sem_memreq1_get_req_next;
        sem_memdone1_sync_req <= sem_memdone1_sync_req_next;
        sem_memdone1_sync_data_address <= sem_memdone1_sync_data_address_next;
        sem_memdone1_sync_data_procId <= sem_memdone1_sync_data_procId_next;
        sem_memdone1_sync_data_type <= sem_memdone1_sync_data_type_next;
        sem_memdone1_sync_data_data <= sem_memdone1_sync_data_data_next;
        FEresponse1_put_req <= FEresponse1_put_req_next;
        FEresult1_put_req <= FEresult1_put_req_next;
        FEresult1_core_data <= FEresult1_core_data_next;
        FEresponse1_core_data <= FEresponse1_core_data_next;
        threadProc_PROC_STATE <= threadProc_PROC_STATE_next;
    end
end

endmodule


